name: 3Ô∏è‚É£ Deploy Board App (AKS)

on:
  workflow_dispatch:
    inputs:
      imageTag:
        description: "ACR „Å´„Éó„ÉÉ„Ç∑„É•Ê∏à„Åø„ÅÆ„Ç§„É°„Éº„Ç∏„Çø„Ç∞ (Êú™ÊåáÂÆöÊôÇ„ÅØ latest)"
        required: false
  workflow_run:
    workflows:
      - "2Ô∏è‚É£ Build Board App"
    types:
      - completed

permissions:
  contents: read
  id-token: write
  actions: write # „Ç¢„Éº„ÉÜ„Ç£„Éï„Ç°„ÇØ„Éà„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ + Variables Êõ∏„ÅçËæº„ÅøÔºàINGRESS_PUBLIC_IPË®≠ÂÆöÔºâ„Å´ÂøÖË¶Å

env:
  RESOURCE_GROUP_NAME: ${{ vars.RESOURCE_GROUP_NAME }}
  AKS_CLUSTER_NAME: ${{ vars.AKS_CLUSTER_NAME }}
  PARAM_FILE: infra/parameters/main-dev.parameters.json
  KUSTOMIZE_DIR: app/board-app/k8s
  ACR_NAME_PREFIX: ${{ vars.ACR_NAME_PREFIX }}
  STORAGE_ACCOUNT_PREFIX: ${{ vars.STORAGE_ACCOUNT_PREFIX }}
  BOARD_IMAGE_NAME: board-app
  BOARD_API_IMAGE_NAME: board-api
  DB_APP_USERNAME: ${{ vars.DB_APP_USERNAME }}
  DB_APP_PASSWORD: ${{ vars.DB_APP_PASSWORD }}
  GH_TOKEN: ${{ github.token }}

jobs:
  prepare-aks:
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    outputs:
      db_endpoint: ${{ steps.mysql_endpoint.outputs.db_endpoint }}
      acr_name: ${{ steps.resolve_acr.outputs.acr_name }}
      acr_login_server: ${{ steps.resolve_acr.outputs.acr_login_server }}
      storage_account_name: ${{ steps.storage_account.outputs.storage_account_name }}
    steps:
      - name: „Ç≥„Éº„Éâ„ÇíÂèñÂæó
        uses: actions/checkout@v4

      - name: Azure „Å´ Service Principal „Åß„É≠„Ç∞„Ç§„É≥
        uses: azure/login@v2
        with:
          creds: >-
            {"clientId":"${{ vars.AZURE_CLIENT_ID }}","tenantId":"${{ vars.AZURE_TENANT_ID }}","clientSecret":"${{ vars.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}"}

      - name: „Ç§„É≥„Éï„É©Âá∫Âäõ„Ç¢„Éº„ÉÜ„Ç£„Éï„Ç°„ÇØ„Éà„Åã„Çâ MySQL IP „ÇíÂèñÂæó
        id: mysql_endpoint
        env:
          GH_TOKEN: ${{ github.token }}
          INFRA_WORKFLOW_NAME: "1Ô∏è‚É£ Infrastructure Deploy"
        run: |
          set -euo pipefail
          mkdir -p infra-output
          if [ "${{ github.event_name }}" = "workflow_run" ] && [ "${{ github.event.workflow_run.name }}" = "$INFRA_WORKFLOW_NAME" ]; then
            TARGET_RUN_ID='${{ github.event.workflow_run.id }}'
            echo "workflow_run „Éà„É™„Ç¨„Éº: run_id=$TARGET_RUN_ID"
          else
            TARGET_RUN_ID=$(curl -s -H "Authorization: token $GH_TOKEN" \
              "https://api.github.com/repos/${{ github.repository }}/actions/workflows/1-infra-deploy.yml/runs?status=success&per_page=1" \
              | jq -r '.workflow_runs[0].id')
            echo "ÊâãÂãïÂÆüË°å: ÊúÄÊñ∞„ÅÆÊàêÂäü„Åó„Åü Infrastructure Deploy run_id=$TARGET_RUN_ID"
          fi
          if [ -z "$TARGET_RUN_ID" ] || [ "$TARGET_RUN_ID" = "null" ]; then
            echo "„Ç§„É≥„Éï„É©„Éá„Éó„É≠„Ç§„ÅÆÂÆüË°åÂ±•Ê≠¥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì" >&2
            exit 1
          fi
          gh run download "$TARGET_RUN_ID" --name infra-outputs --dir infra-output >/dev/null
          OUTPUT_FILE=$(find infra-output -name '*.json' | head -n1)
          if [ -z "$OUTPUT_FILE" ]; then
            echo "infra-outputs „Ç¢„Éº„ÉÜ„Ç£„Éï„Ç°„ÇØ„Éà„Å´ JSON „ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì" >&2
            exit 1
          fi
          MYSQL_IP=$(jq -r '.mysqlPrivateIp.value' "$OUTPUT_FILE")
          if [ -z "$MYSQL_IP" ] || [ "$MYSQL_IP" = "null" ]; then
            echo "infra Âá∫Âäõ„Å´ mysqlPrivateIp „ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì" >&2
            exit 1
          fi
          echo "db_endpoint=${MYSQL_IP}:3306" >> "$GITHUB_OUTPUT"
          echo "Resolved MySQL endpoint: ${MYSQL_IP}:3306"

      - name: ACR Âêç„ÇíËß£Ê±∫
        id: resolve_acr
        run: |
          set -euo pipefail
          if [ -z "$ACR_NAME_PREFIX" ] || [ -z "$RESOURCE_GROUP_NAME" ]; then
            echo "ACR Âêç„ÇíÊ±∫ÂÆö„Åô„Çã„Åü„ÇÅ„ÅÆÂ§âÊï∞„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„Åæ„Åô" >&2
            exit 1
          fi
          ACR_NAME=$(az acr list \
            --resource-group "$RESOURCE_GROUP_NAME" \
            --query "[?starts_with(name, '${ACR_NAME_PREFIX}')].name | [0]" \
            -o tsv)
          if [ -z "$ACR_NAME" ]; then
            echo "ÊåáÂÆö„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÅÆ ACR „ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇinfra-deploy „ÇíÂÖà„Å´ÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ" >&2
            exit 1
          fi
          echo "acr_name=$ACR_NAME" >> "$GITHUB_OUTPUT"
          echo "acr_login_server=${ACR_NAME}.azurecr.io" >> "$GITHUB_OUTPUT"

      - name: Storage Account Âêç„ÇíËß£Ê±∫
        id: storage_account
        run: |
          set -euo pipefail
          STORAGE_NAME=$(az storage account list \
            --resource-group "$RESOURCE_GROUP_NAME" \
            --query "[?starts_with(name, '${STORAGE_ACCOUNT_PREFIX}')].name | [0]" \
            -o tsv)
          if [ -z "$STORAGE_NAME" ]; then
            echo "ÊåáÂÆö„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÅÆ Storage Account „ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì" >&2
            exit 1
          fi
          echo "storage_account_name=$STORAGE_NAME" >> "$GITHUB_OUTPUT"

  ingress-controller:
    runs-on: ubuntu-latest
    needs: prepare-aks
    if: ${{ needs.prepare-aks.result == 'success' && (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success') }}
    env:
      DB_ENDPOINT: ${{ needs.prepare-aks.outputs.db_endpoint }}
      ACR_NAME: ${{ needs.prepare-aks.outputs.acr_name }}
      ACR_LOGIN_SERVER: ${{ needs.prepare-aks.outputs.acr_login_server }}
      STORAGE_ACCOUNT_NAME: ${{ needs.prepare-aks.outputs.storage_account_name }}
    steps:
      - name: „Ç≥„Éº„Éâ„ÇíÂèñÂæó
        uses: actions/checkout@v4

      - name: Azure „Å´ Service Principal „Åß„É≠„Ç∞„Ç§„É≥
        uses: azure/login@v2
        with:
          creds: >-
            {"clientId":"${{ vars.AZURE_CLIENT_ID }}","tenantId":"${{ vars.AZURE_TENANT_ID }}","clientSecret":"${{ vars.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}"}

      - name: kubectl „ÇíÊ∫ñÂÇô
        run: az aks install-cli

      - name: AKS Ë≥áÊ†ºÊÉÖÂ†±„ÇíÂèñÂæó
        run: |
          az aks get-credentials \
            --name "$AKS_CLUSTER_NAME" \
            --resource-group "$RESOURCE_GROUP_NAME" \
            --overwrite-existing

      - name: Ingress Áî® Static Public IP „ÇíÁ¢∫‰øù
        run: |
          set -euo pipefail
          AKS_LOCATION=$(az aks show \
            --resource-group "$RESOURCE_GROUP_NAME" \
            --name "$AKS_CLUSTER_NAME" \
            --query location -o tsv)
          NODE_RG=$(az aks show \
            --resource-group "$RESOURCE_GROUP_NAME" \
            --name "$AKS_CLUSTER_NAME" \
            --query nodeResourceGroup -o tsv)
          if [ -z "$NODE_RG" ]; then
            echo "AKS „ÅÆ„Éé„Éº„Éâ„É™„ÇΩ„Éº„Çπ„Ç∞„É´„Éº„Éó„ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì" >&2
            exit 1
          fi
          PIP_NAME=$(jq -r '.parameters.ingressPublicIpName.value // empty' "$PARAM_FILE")
          if [ -z "$PIP_NAME" ]; then
            echo "parameters „Éï„Ç°„Ç§„É´„Å´ ingressPublicIpName „ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì" >&2
            exit 1
          fi
          echo "NODE_RESOURCE_GROUP=$NODE_RG" >> "$GITHUB_ENV"
          echo "INGRESS_PIP_NAME=$PIP_NAME" >> "$GITHUB_ENV"
          STATIC_IP=$(az network public-ip show \
            --resource-group "$NODE_RG" \
            --name "$PIP_NAME" \
            --query ipAddress -o tsv 2>/dev/null || true)
          if [ -z "$STATIC_IP" ]; then
            echo "Node RG ($NODE_RG) „Å´ Public IP $PIP_NAME „ÅåÁÑ°„ÅÑ„Åü„ÇÅ‰ΩúÊàê„Åó„Åæ„Åô"
            az network public-ip create \
              --resource-group "$NODE_RG" \
              --name "$PIP_NAME" \
              --sku Standard \
              --location "$AKS_LOCATION" \
              --allocation-method static \
              --version IPv4 \
              --tags project=container-app-demo environment=dev
            STATIC_IP=$(az network public-ip show \
              --resource-group "$NODE_RG" \
              --name "$PIP_NAME" \
              --query ipAddress -o tsv)
          else
            echo "Êó¢Â≠ò„ÅÆ Public IP ($STATIC_IP) „ÇíÂÜçÂà©Áî®„Åó„Åæ„Åô"
          fi
          if [ -z "$STATIC_IP" ]; then
            echo "Public IP „ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü" >&2
            exit 1
          fi
          echo "INGRESS_STATIC_IP=$STATIC_IP" >> "$GITHUB_ENV"
          echo "Âõ∫ÂÆö IP: $STATIC_IP (Resource Group: $NODE_RG)"

      - name: NSG „Å´ Load Balancer ÈÄö‰ø°Áî®„É´„Éº„É´„ÇíÈÅ©Áî®
        run: |
          set -euo pipefail
          NODE_RG="${NODE_RESOURCE_GROUP:-}"
          if [ -z "$NODE_RG" ]; then
            NODE_RG=$(az aks show \
              --resource-group "$RESOURCE_GROUP_NAME" \
              --name "$AKS_CLUSTER_NAME" \
              --query nodeResourceGroup -o tsv)
          fi
          if [ -z "$NODE_RG" ]; then
            echo "AKS „ÅÆ„Éé„Éº„Éâ„É™„ÇΩ„Éº„Çπ„Ç∞„É´„Éº„Éó„ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì" >&2
            exit 1
          fi
          NSG_NAME=$(az network nsg list \
            --resource-group "$NODE_RG" \
            --query "[?contains(name, 'aks-agentpool')].name | [0]" -o tsv)
          if [ -z "$NSG_NAME" ]; then
            echo "AKS „ÅåÁÆ°ÁêÜ„Åô„Çã NSG „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: rg=$NODE_RG" >&2
            exit 1
          fi
          ensure_rule() {
            local rule_name=$1
            local source_prefix=$2
            local ports=$3
            local priority=$4
            az network nsg rule create \
              --resource-group "$NODE_RG" \
              --nsg-name "$NSG_NAME" \
              --name "$rule_name" \
              --priority "$priority" \
              --access Allow \
              --direction Inbound \
              --protocol Tcp \
              --source-address-prefixes "$source_prefix" \
              --destination-port-ranges "$ports" >/dev/null
          }
          ensure_rule "allow-azure-lb-probes" AzureLoadBalancer 30000-32767 300
          ensure_rule "allow-nodeport-from-internet" Internet 30000-32767 310
          echo "NSG $NSG_NAME „Å´ Load Balancer ÂÅ•Â∫∑„ÉÅ„Çß„ÉÉ„ÇØ/„Éá„Éº„Çø„Éó„É¨„Éº„É≥Áî®„É´„Éº„É´„ÇíÈÅ©Áî®„Åó„Åæ„Åó„Åü"

      - name: Ingress Controller (nginx) „ÇíÁ¢∫Ë™ç/„Ç§„É≥„Çπ„Éà„Éº„É´
        run: |
          set -euo pipefail
          NODE_RG="${NODE_RESOURCE_GROUP:-}"
          if [ -z "$NODE_RG" ]; then
            NODE_RG=$(az aks show \
              --resource-group "$RESOURCE_GROUP_NAME" \
              --name "$AKS_CLUSTER_NAME" \
              --query nodeResourceGroup -o tsv)
          fi
          STATIC_IP="${INGRESS_STATIC_IP:-}"
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx || true
          helm repo update
          CONTROLLER_IMAGE="ingress-nginx/controller"
          INGRESS_APP_VERSION=$(helm show chart ingress-nginx/ingress-nginx | awk -F': ' '/^appVersion:/ {print $2}' | tr -d '[:space:]')
          if [ -z "$INGRESS_APP_VERSION" ] || [ "$INGRESS_APP_VERSION" = "null" ]; then
            echo "ingress-nginx „ÅÆ appVersion „ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì" >&2
            exit 1
          fi
          if [[ "$INGRESS_APP_VERSION" == v* ]]; then
            CONTROLLER_TAG="$INGRESS_APP_VERSION"
          else
            CONTROLLER_TAG="v${INGRESS_APP_VERSION}"
          fi
          echo "ingress-nginx controller „Çø„Ç∞: $CONTROLLER_TAG"

          # ACR „Ç§„É≥„Éù„Éº„Éà (registry.k8s.io „Çí‰ΩøÁî®„ÄÅMCR „ÅØ„Éü„É©„Éº„ÅÆ„Åü„ÇÅ)
          echo "ACR „Å´ ingress-nginx controller „Ç§„É°„Éº„Ç∏„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„Åæ„Åô"
          az acr import \
            --name "$ACR_NAME" \
            --source "registry.k8s.io/${CONTROLLER_IMAGE}:${CONTROLLER_TAG}" \
            --image "${CONTROLLER_IMAGE}:${CONTROLLER_TAG}" \
            --force || {
              echo "‚ö†Ô∏è registry.k8s.io „Åã„Çâ„ÅÆ„Ç§„É≥„Éù„Éº„ÉàÂ§±Êïó„ÄÅMCR „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„ÇíË©¶Ë°å"
              az acr import \
                --name "$ACR_NAME" \
                --source "mcr.microsoft.com/oss/kubernetes/${CONTROLLER_IMAGE}:${CONTROLLER_TAG}" \
                --image "${CONTROLLER_IMAGE}:${CONTROLLER_TAG}" \
                --force
            }

          # Helm „É™„É™„Éº„Çπ„ÅÆ„É≠„ÉÉ„ÇØÁä∂ÊÖã„ÇíÁ¢∫Ë™ç„ÉªËß£Èô§
          if kubectl get ns ingress-nginx >/dev/null 2>&1 && kubectl get secret -n ingress-nginx | grep -q 'sh\.helm\.release\.v1\.ingress-nginx'; then
            echo "Helm „É™„É™„Éº„Çπ„ÅÆÁä∂ÊÖã„ÇíÁ¢∫Ë™ç„Åó„Åæ„Åô"
            HELM_STATUS=$(helm status ingress-nginx -n ingress-nginx -o json 2>/dev/null | jq -r '.info.status' || echo "unknown")
            if [[ "$HELM_STATUS" == "pending-install" || "$HELM_STATUS" == "pending-upgrade" || "$HELM_STATUS" == "pending-rollback" ]]; then
              echo "‚ö†Ô∏è  Helm „É™„É™„Éº„Çπ„Åå„É≠„ÉÉ„ÇØÁä∂ÊÖãÔºà$HELM_STATUSÔºâ„Åß„Åô„ÄÇ„É≠„ÉÉ„ÇØ„ÇíËß£Èô§„Åó„Åæ„Åô"
              helm rollback ingress-nginx 0 -n ingress-nginx --wait=false || kubectl delete secret -n ingress-nginx -l owner=helm,name=ingress-nginx,status=pending-install || true
              sleep 5
            fi
          fi

          # values.yaml „Éô„Éº„Çπ„ÅÆË®≠ÂÆö + ÂãïÁöÑ„Éë„É©„É°„Éº„Çø„Çí --set „Åß‰∏äÊõ∏„Åç
          VALUES_FILE="app/board-app/k8s/ingress-nginx-values.yaml"
          OVERRIDE_ARGS="--set controller.image.registry=$ACR_LOGIN_SERVER --set controller.image.image=$CONTROLLER_IMAGE --set controller.image.tag=$CONTROLLER_TAG"

          if [ -n "$STATIC_IP" ] && [ -n "$NODE_RG" ]; then
            echo "‚úÖ Static Public IP „Çí‰ΩøÁî®: $STATIC_IP (Resource Group: $NODE_RG)"
            OVERRIDE_ARGS="$OVERRIDE_ARGS --set controller.service.loadBalancerIP=$STATIC_IP --set controller.service.annotations.\"service\.beta\.kubernetes\.io/azure-load-balancer-resource-group\"=$NODE_RG"
          else
            echo "‚ö†Ô∏è Static Public IP ÊÉÖÂ†±„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇDynamic IP „ÅåÂâ≤„ÇäÂΩì„Å¶„Çâ„Çå„Åæ„Åô"
          fi

          # Helm „É™„É™„Éº„Çπ„ÅåÂ≠òÂú®„Åô„Çã„ÅãÁ¢∫Ë™ç
          if helm status ingress-nginx -n ingress-nginx &>/dev/null; then
            echo "‚úÖ Helm „É™„É™„Éº„Çπ„ÅåÂ≠òÂú®„Åó„Åæ„Åô„ÄÇupgrade „ÇíÂÆüË°å"
            # Êó¢Â≠ò„ÅÆ LoadBalancer „ÇíÂâäÈô§„Åó„Å¶ÂÜç‰ΩúÊàê„ÇíÂº∑Âà∂
            kubectl delete svc ingress-nginx-controller -n ingress-nginx --ignore-not-found=true
            sleep 10
            
            helm upgrade ingress-nginx ingress-nginx/ingress-nginx \
              --namespace ingress-nginx \
              --values "$VALUES_FILE" \
              $OVERRIDE_ARGS \
              --wait --timeout=10m || {
                echo "‚ö†Ô∏è upgrade Â§±Êïó„ÄÇ„É™„É™„Éº„Çπ„ÇíÂÆåÂÖ®„Å´ÂâäÈô§„Åó„Å¶ install „Å´Âàá„ÇäÊõø„Åà„Åæ„Åô"
                helm uninstall ingress-nginx -n ingress-nginx --wait || true
                kubectl delete ns ingress-nginx --ignore-not-found=true
                sleep 10
                kubectl create namespace ingress-nginx
                helm install ingress-nginx ingress-nginx/ingress-nginx \
                  --namespace ingress-nginx \
                  --values "$VALUES_FILE" \
                  $OVERRIDE_ARGS \
                  --wait --timeout=10m
              }
          else
            echo "‚úÖ Êñ∞Ë¶è install „ÇíÂÆüË°å"
            kubectl create namespace ingress-nginx --dry-run=client -o yaml | kubectl apply -f -
            helm install ingress-nginx ingress-nginx/ingress-nginx \
              --namespace ingress-nginx \
              --values "$VALUES_FILE" \
              $OVERRIDE_ARGS \
              --wait --timeout=10m
          fi

          echo "ingress-nginx controller „ÅÆ„É≠„Éº„É´„Ç¢„Ç¶„ÉàÂÆå‰∫Ü„ÇíÂæÖÊ©ü„Åó„Åæ„Åô"
          kubectl rollout status deployment/ingress-nginx-controller -n ingress-nginx --timeout=600s

          echo "LoadBalancer IP „ÅÆÂâ≤„ÇäÂΩì„Å¶„ÇíÂæÖÊ©ü„Åó„Åæ„Åô (ÊúÄÂ§ß 10ÂàÜ)"
          ATTEMPTS=60
          for i in $(seq 1 $ATTEMPTS); do
            LB_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            if [ -n "$LB_IP" ]; then
              echo "‚úÖ LoadBalancer IP ÂèñÂæóÊàêÂäü: $LB_IP"
              echo "ACTUAL_LB_IP=$LB_IP" >> "$GITHUB_ENV"
              break
            fi
            echo "[$i/$ATTEMPTS] LoadBalancer IP Ââ≤„ÇäÂΩì„Å¶ÂæÖÊ©ü‰∏≠..."
            sleep 10
          done

          if [ -z "${LB_IP:-}" ]; then
            echo "‚ùå Ë¶èÂÆöÊôÇÈñìÂÜÖ„Å´ LoadBalancer IP „ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü" >&2
            kubectl describe svc ingress-nginx-controller -n ingress-nginx
            exit 1
          fi

      - name: LoadBalancer Êé•Á∂öÁ¢∫Ë™ç
        run: |
          set -euo pipefail
          LB_IP="${ACTUAL_LB_IP:-}"
          if [ -z "$LB_IP" ]; then
            LB_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          fi

          if [ -z "$LB_IP" ]; then
            echo "‚ùå LoadBalancer IP „ÅåÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì" >&2
            exit 1
          fi

          echo "LoadBalancer ($LB_IP) „Å∏„ÅÆ„Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ„ÇíÂÆüË°å„Åó„Åæ„Åô"
          HEALTH_CHECK_ATTEMPTS=30
          for i in $(seq 1 $HEALTH_CHECK_ATTEMPTS); do
            if kubectl exec -n ingress-nginx deployment/ingress-nginx-controller -- curl -s -o /dev/null -w "%{http_code}" http://localhost:10254/healthz | grep -q "200"; then
              echo "‚úÖ [$i/$HEALTH_CHECK_ATTEMPTS] Ingress Controller „Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØÊàêÂäü"
              break
            fi
            echo "[$i/$HEALTH_CHECK_ATTEMPTS] „Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØÂæÖÊ©ü‰∏≠..."
            sleep 5
          done

          echo "Azure LoadBalancer „ÅÆ„Éò„É´„Çπ„Éó„É≠„Éº„ÉñË®≠ÂÆö„ÇíÁ¢∫Ë™ç„Åó„Åæ„Åô"
          NODE_RG="${NODE_RESOURCE_GROUP:-}"
          if [ -n "$NODE_RG" ]; then
            PROBE_INFO=$(az network lb probe list \
              --resource-group "$NODE_RG" \
              --lb-name kubernetes \
              --query "[?contains(name, 'ae3f94b3d23304b5c99316a6da9704ef')].{Name:name, Port:port, Path:requestPath, Protocol:protocol}" \
              -o json 2>/dev/null || echo "[]")
            
            if [ "$PROBE_INFO" != "[]" ]; then
              echo "‚úÖ LoadBalancer „Éò„É´„Çπ„Éó„É≠„Éº„ÉñË®≠ÂÆö:"
              echo "$PROBE_INFO" | jq '.'
            else
              echo "‚ö†Ô∏è „Éò„É´„Çπ„Éó„É≠„Éº„ÉñÊÉÖÂ†±„ÅåÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„ÅüÔºà‰ΩúÊàê‰∏≠„ÅÆÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„ÅôÔºâ"
            fi
          fi

          echo "LoadBalancer „ÅÆÊ∫ñÂÇôÂÆå‰∫Ü„ÇíÂæÖÊ©ü„Åó„Åæ„ÅôÔºàÊúÄÂ§ß 5ÂàÜÔºâ"
          CONNECTIVITY_ATTEMPTS=30
          for i in $(seq 1 $CONNECTIVITY_ATTEMPTS); do
            if timeout 5 bash -c "echo > /dev/tcp/$LB_IP/80" 2>/dev/null; then
              echo "‚úÖ [$i/$CONNECTIVITY_ATTEMPTS] LoadBalancer „Éù„Éº„Éà 80 „Å∏„ÅÆÊé•Á∂öÊàêÂäü"
              break
            fi
            echo "[$i/$CONNECTIVITY_ATTEMPTS] LoadBalancer Êé•Á∂öÂæÖÊ©ü‰∏≠..."
            sleep 10
          done

      - name: Ingress Controller Áä∂ÊÖã„ÇíË®òÈå≤
        if: success()
        run: |
          echo "### üåê Ingress Controller Áä∂ÊÖã" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "```" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n ingress-nginx >> $GITHUB_STEP_SUMMARY || true
          kubectl get svc -n ingress-nginx >> $GITHUB_STEP_SUMMARY || true
          echo "```" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          LB_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "N/A")
          echo "**LoadBalancer IP:** \`$LB_IP\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

  workload-rollout:
    runs-on: ubuntu-latest
    needs: [prepare-aks, ingress-controller]
    if: ${{ needs.ingress-controller.result == 'success' && (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success') }}
    env:
      DB_ENDPOINT: ${{ needs.prepare-aks.outputs.db_endpoint }}
      ACR_NAME: ${{ needs.prepare-aks.outputs.acr_name }}
      ACR_LOGIN_SERVER: ${{ needs.prepare-aks.outputs.acr_login_server }}
    outputs:
      image_tag: ${{ steps.image_meta.outputs.image_tag }}
      image_full: ${{ steps.image_meta.outputs.image_full }}
      board_api_image_full: ${{ steps.image_meta.outputs.board_api_image_full }}
    steps:
      - name: „Ç≥„Éº„Éâ„ÇíÂèñÂæó
        uses: actions/checkout@v4

      - name: Azure „Å´ Service Principal „Åß„É≠„Ç∞„Ç§„É≥
        uses: azure/login@v2
        with:
          creds: >-
            {"clientId":"${{ vars.AZURE_CLIENT_ID }}","tenantId":"${{ vars.AZURE_TENANT_ID }}","clientSecret":"${{ vars.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}"}

      - name: kubectl „ÇíÊ∫ñÂÇô
        run: az aks install-cli

      - name: Namespace/Ingress „ÅÆÂÄ§„ÇíÂêåÊúü
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          & ./scripts/sync-board-vars.ps1 `
            -ParametersFile "infra/parameters/main-dev.parameters.json" `
            -OutputFile "app/board-app/k8s/vars.env"

      - name: AKS „Å´ ACR Pull Ê®©Èôê„Çí‰ªò‰∏é
        continue-on-error: true
        run: |
          if az aks check-acr --name "$AKS_CLUSTER_NAME" --resource-group "$RESOURCE_GROUP_NAME" --acr "${ACR_LOGIN_SERVER}" &>/dev/null; then
            echo "ACR Pull Ê®©Èôê„ÅØÊó¢„Å´‰ªò‰∏é„Åï„Çå„Å¶„ÅÑ„Åæ„Åô"
          else
            echo "ACR Pull Ê®©Èôê„Çí‰ªò‰∏é„Åó„Åæ„Åô"
            az aks update \
              --name "$AKS_CLUSTER_NAME" \
              --resource-group "$RESOURCE_GROUP_NAME" \
              --attach-acr "$ACR_NAME" || echo "‚ö†Ô∏è ACR Ê®©Èôê‰ªò‰∏é„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„Åå„ÄÅÊó¢Â≠ò„ÅÆÊ®©Èôê„ÅßÁ∂ôÁ∂ö„Åó„Åæ„Åô"
          fi

      - name: AKS Ë≥áÊ†ºÊÉÖÂ†±„ÇíÂèñÂæó
        run: |
          az aks get-credentials \
            --name "$AKS_CLUSTER_NAME" \
            --resource-group "$RESOURCE_GROUP_NAME" \
            --overwrite-existing

      - name: Ingress Admission Webhook „ÅÆÊ∫ñÂÇô„ÇíÂæÖÊ©ü
        run: |
          set -euo pipefail
          echo "Ingress Controller „ÅÆ Admission Webhook Pod „Åå Ready „Å´„Å™„Çã„Åæ„ÅßÂæÖÊ©ü„Åó„Åæ„Åô (ÊúÄÂ§ß 3ÂàÜ)"
          ATTEMPTS=18
          for i in $(seq 1 $ATTEMPTS); do
            READY_COUNT=$(kubectl get pods -n ingress-nginx -l app.kubernetes.io/component=controller -o jsonpath='{.items[*].status.conditions[?(@.type=="Ready")].status}' 2>/dev/null | grep -c "True" || echo "0")
            if [ "$READY_COUNT" -ge 1 ]; then
              echo "‚úÖ Ingress Controller Pod „Åå Ready „Åß„Åô"
              # Admission Webhook „ÅÆ„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„ÅåÊúâÂäπ„ÅãÁ¢∫Ë™ç
              sleep 5
              if kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io ingress-nginx-admission >/dev/null 2>&1; then
                echo "‚úÖ Admission Webhook Ë®≠ÂÆö„ÅåÂ≠òÂú®„Åó„Åæ„Åô"
                break
              else
                echo "‚ö†Ô∏è Admission Webhook Ë®≠ÂÆö„Åå„Åæ„Å†‰ΩúÊàê„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇÂÜçË©¶Ë°å„Åó„Åæ„Åô..."
              fi
            fi
            echo "[$i/$ATTEMPTS] Ingress Controller Pod „ÅÆËµ∑Âãï„ÇíÂæÖÊ©ü‰∏≠..."
            sleep 10
          done
          if [ "$READY_COUNT" -lt 1 ]; then
            echo "::warning::Ingress Controller Pod „Åå Ready „Å´„Å™„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇË®∫Êñ≠ÊÉÖÂ†±„ÇíÂá∫Âäõ„Åó„Åæ„Åô„ÄÇ"
            kubectl get pods -n ingress-nginx -o wide || true
            kubectl describe pods -n ingress-nginx || true
            exit 1
          fi

      - name: ACR ÁÆ°ÁêÜËÄÖË™çË®º„ÇíÊúâÂäπÂåñ
        run: |
          az acr update --name "$ACR_NAME" --admin-enabled true

      - name: ACR Ë™çË®ºÊÉÖÂ†±„Åß Secret „Çí‰ΩúÊàê
        run: |
          BOARD_NS=$(grep kubernetesNamespace "${KUSTOMIZE_DIR}/vars.env" | cut -d'=' -f2)
          kubectl create namespace "$BOARD_NS" --dry-run=client -o yaml | kubectl apply -f -
          ACR_USERNAME=$(az acr credential show --name "$ACR_NAME" --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name "$ACR_NAME" --query "passwords[0].value" -o tsv)
          kubectl create secret docker-registry acr-secret \
            --docker-server="$ACR_LOGIN_SERVER" \
            --docker-username="$ACR_USERNAME" \
            --docker-password="$ACR_PASSWORD" \
            -n "$BOARD_NS" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: „Éá„Éó„É≠„Ç§„Å´‰ΩøÁî®„Åô„Çã„Ç§„É°„Éº„Ç∏„ÇíÊ±∫ÂÆö
        id: image_meta
        run: |
          set -euo pipefail
          EVENT_NAME='${{ github.event_name }}'

          # „Ç§„Éô„É≥„Éà„Çø„Ç§„Éó„Å´Âøú„Åò„Å¶„Çø„Ç∞„ÇíÊ±∫ÂÆö
          if [ "$EVENT_NAME" = 'workflow_run' ]; then
            HEAD_SHA='${{ github.event.workflow_run.head_sha }}'
            IMAGE_TAG="${HEAD_SHA:0:12}"
          else
            IMAGE_TAG='${{ github.event.inputs.imageTag }}'
          fi

          # „Çø„Ç∞„ÅåÁ©∫„Åæ„Åü„ÅØÊåáÂÆö„Åï„Çå„Åü„Çø„Ç∞„Åå ACR „Å´Â≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØÊúÄÊñ∞„Çø„Ç∞„ÇíÂèñÂæó
          if [ -z "$IMAGE_TAG" ]; then
            echo "„Ç§„É°„Éº„Ç∏„Çø„Ç∞„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇACR „Åã„ÇâÊúÄÊñ∞„Çø„Ç∞„ÇíÂèñÂæó„Åó„Åæ„Åô..."
            NEED_FALLBACK=true
          else
            echo "ÊåáÂÆö„Åï„Çå„Åü„Ç§„É°„Éº„Ç∏„Çø„Ç∞: $IMAGE_TAG"
            # ACR „Å´„Çø„Ç∞„ÅåÂ≠òÂú®„Åô„Çã„ÅãÁ¢∫Ë™ç
            if az acr repository show-tags --name "$ACR_NAME" --repository "$BOARD_IMAGE_NAME" --output tsv 2>/dev/null | grep -q "^${IMAGE_TAG}$"; then
              echo "‚úÖ „Çø„Ç∞ $IMAGE_TAG „ÅØ ACR „Å´Â≠òÂú®„Åó„Åæ„Åô"
              NEED_FALLBACK=false
            else
              echo "‚ö†Ô∏è „Çø„Ç∞ $IMAGE_TAG „ÅØ ACR „Å´Â≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇÊúÄÊñ∞„Çø„Ç∞„ÇíÂèñÂæó„Åó„Åæ„Åô..."
              NEED_FALLBACK=true
            fi
          fi

          # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ACR „Åã„ÇâÊúÄÊñ∞„ÅÆ„Çø„Ç∞„ÇíÂèñÂæó
          if [ "$NEED_FALLBACK" = "true" ]; then
            LATEST_TAG=$(az acr repository show-tags \
              --name "$ACR_NAME" \
              --repository "$BOARD_IMAGE_NAME" \
              --orderby time_desc \
              --output tsv \
              --top 1 2>/dev/null || echo "")
            
            if [ -n "$LATEST_TAG" ]; then
              IMAGE_TAG="$LATEST_TAG"
              echo "‚úÖ ACR „Åã„ÇâÊúÄÊñ∞„Çø„Ç∞„ÇíÂèñÂæó„Åó„Åæ„Åó„Åü: $IMAGE_TAG"
            else
              echo "::warning::ACR „Å´„Ç§„É°„Éº„Ç∏„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇlatest „Çí‰ΩøÁî®„Åó„Åæ„Åô„Åå„ÄÅ„Éá„Éó„É≠„Ç§„ÅØÂ§±Êïó„Åô„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô"
              IMAGE_TAG='latest'
            fi
          fi

          IMAGE_FULL="$ACR_LOGIN_SERVER/$BOARD_IMAGE_NAME:$IMAGE_TAG"
          BOARD_API_IMAGE_FULL="$ACR_LOGIN_SERVER/$BOARD_API_IMAGE_NAME:$IMAGE_TAG"

          echo "IMAGE_TAG=$IMAGE_TAG" >> "$GITHUB_ENV"
          echo "IMAGE_FULL=$IMAGE_FULL" >> "$GITHUB_ENV"
          echo "BOARD_API_IMAGE_FULL=$BOARD_API_IMAGE_FULL" >> "$GITHUB_ENV"
          echo "image_tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          echo "image_full=$IMAGE_FULL" >> "$GITHUB_OUTPUT"
          echo "board_api_image_full=$BOARD_API_IMAGE_FULL" >> "$GITHUB_OUTPUT"

          echo "### üì¶ „Éá„Éó„É≠„Ç§„Ç§„É°„Éº„Ç∏ÊÉÖÂ†±" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "- **Image Tag**: \`$IMAGE_TAG\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- **Board App**: \`$IMAGE_FULL\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- **Board API**: \`$BOARD_API_IMAGE_FULL\`" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

      - name: DB Êé•Á∂ö Secret(board-db-conn) „Çí‰ΩúÊàê/Êõ¥Êñ∞
        run: |
          set -euo pipefail
          BOARD_NS=$(grep kubernetesNamespace "${KUSTOMIZE_DIR}/vars.env" | cut -d'=' -f2)
          kubectl create namespace "$BOARD_NS" --dry-run=client -o yaml | kubectl apply -f -
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Secret
          metadata:
            name: board-db-conn
            namespace: ${BOARD_NS}
          type: Opaque
          stringData:
            db-endpoint: "${DB_ENDPOINT}"
            db-username: "${DB_APP_USERNAME}"
            db-password: "${DB_APP_PASSWORD}"
          EOF
          echo "board-db-conn Secret ‰ΩúÊàê/Êõ¥Êñ∞ÂÆå‰∫Ü (DB_ENDPOINT=${DB_ENDPOINT})"
          echo "‚ö†Ô∏è „Çª„Ç≠„É•„É™„ÉÜ„Ç£: DB_APP_PASSWORD „ÅØ GitHub Secrets „Å∏„ÅÆÁßªË°å„ÇíÊé®Â•®„Åó„Åæ„Åô" >> $GITHUB_STEP_SUMMARY

      - name: Kustomize „ÇíÈÅ©Áî®
        run: |
          set -euo pipefail
          BOARD_NS=$(grep kubernetesNamespace "${KUSTOMIZE_DIR}/vars.env" | cut -d'=' -f2)
          kubectl kustomize "$KUSTOMIZE_DIR" \
            | sed "s#acr-placeholder.azurecr.io/board-app:latest#${IMAGE_FULL}#g" \
            | sed "s#acr-placeholder.azurecr.io/board-api:latest#${BOARD_API_IMAGE_FULL}#g" \
            | kubectl apply -f -

          collect_rollout_diagnostics() {
            local deploy="$1"
            echo "::group::${deploy} rollout diagnostics"
            kubectl get pods -n "$BOARD_NS" -l app="$deploy" || true
            kubectl describe deployment "$deploy" -n "$BOARD_NS" || true
            kubectl get events -n "$BOARD_NS" --field-selector "involvedObject.name=${deploy}" --sort-by='.lastTimestamp' | tail -n 20 || true
            echo "::endgroup::"
            {
              echo "### ‚ö†Ô∏è ${deploy} Rollout Diagnostics"
              echo ""
              echo "```"
              kubectl get pods -n "$BOARD_NS" -l app="$deploy" || true
              echo "```"
              echo ""
            } >> "$GITHUB_STEP_SUMMARY"
          }

          wait_rollout() {
            local deploy="$1"
            local timeout="$2"
            local mode="${3:-fail}"
            if ! kubectl rollout status deployment/"$deploy" -n "$BOARD_NS" --timeout="${timeout}s"; then
              echo "::warning::${deploy} rollout did not complete within ${timeout}s"
              collect_rollout_diagnostics "$deploy"
              if [ "$mode" = "fail" ]; then
                exit 1
              else
                echo "‚ö†Ô∏è ${deploy} „ÅÆ„É≠„Éº„É´„Ç¢„Ç¶„Éà„ÅØÊú™ÂÆå‰∫Ü„Å†„Åå„ÉØ„Éº„ÇØ„Éï„É≠„Éº„ÅØÁ∂ôÁ∂ö (DB Êé•Á∂öÂæÖ„Å°Á≠â„ÅÆÊó¢Áü•‰∫ãË±°)"
              fi
            fi
          }

          wait_rollout "board-app" 420 fail
          wait_rollout "board-api" 420 warn
          kubectl get ingress -n "$BOARD_NS"

  post-deploy-summary:
    runs-on: ubuntu-latest
    needs: [ingress-controller, workload-rollout]
    if: ${{ needs.ingress-controller.result == 'success' && needs.workload-rollout.result == 'success' && (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success') }}
    env:
      DB_ENDPOINT: ${{ needs.prepare-aks.outputs.db_endpoint }}
      ACR_LOGIN_SERVER: ${{ needs.prepare-aks.outputs.acr_login_server }}
      IMAGE_FULL: ${{ needs.workload-rollout.outputs.image_full }}
      BOARD_API_IMAGE_FULL: ${{ needs.workload-rollout.outputs.board_api_image_full }}
    steps:
      - name: „Ç≥„Éº„Éâ„ÇíÂèñÂæó
        uses: actions/checkout@v4

      - name: Azure „Å´ Service Principal „Åß„É≠„Ç∞„Ç§„É≥
        uses: azure/login@v2
        with:
          creds: >-
            {"clientId":"${{ vars.AZURE_CLIENT_ID }}","tenantId":"${{ vars.AZURE_TENANT_ID }}","clientSecret":"${{ vars.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}"}

      - name: kubectl „ÇíÊ∫ñÂÇô
        run: az aks install-cli

      - name: Namespace/Ingress „ÅÆÂÄ§„ÇíÂêåÊúü
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          & ./scripts/sync-board-vars.ps1 `
            -ParametersFile "infra/parameters/main-dev.parameters.json" `
            -OutputFile "app/board-app/k8s/vars.env"

      - name: AKS Ë≥áÊ†ºÊÉÖÂ†±„ÇíÂèñÂæó
        run: |
          az aks get-credentials \
            --name "$AKS_CLUSTER_NAME" \
            --resource-group "$RESOURCE_GROUP_NAME" \
            --overwrite-existing

      - name: „Éá„Éó„É≠„Ç§„Çµ„Éû„É™„ÇíÂá∫Âäõ
        run: |
          BOARD_NS=$(grep kubernetesNamespace "${KUSTOMIZE_DIR}/vars.env" | cut -d'=' -f2)
          INGRESS_HOST=$(grep ingressHost "${KUSTOMIZE_DIR}/vars.env" | cut -d'=' -f2)
          LB_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          if [ -z "$LB_IP" ]; then
            LB_IP=$(kubectl get svc -A -o json | jq -r '.items[] | select(.spec.type=="LoadBalancer") | .status.loadBalancer.ingress[0].ip' | head -n1 2>/dev/null || echo "")
          fi
          echo "## üéØ Êé≤Á§∫Êùø„Ç¢„Éó„É™ AKS „Éá„Éó„É≠„Ç§ÂÆå‰∫Ü" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üöÄ „Éá„Éó„É≠„Ç§ÊÉÖÂ†±" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **AKS „ÇØ„É©„Çπ„Çø**: \`$AKS_CLUSTER_NAME\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: \`$BOARD_NS\`" >> $GITHUB_STEP_SUMMARY
          echo "- **„Ç§„É°„Éº„Ç∏**: \`${IMAGE_FULL}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìç „Ç¢„ÇØ„Çª„ÇπÊÉÖÂ†±" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -n "$LB_IP" ]; then
            echo "- **Load Balancer IP**: \`$LB_IP\`" >> $GITHUB_STEP_SUMMARY
            echo "- **„Ç¢„ÇØ„Çª„ÇπURL**: http://$LB_IP" >> $GITHUB_STEP_SUMMARY
            echo "- **„ÉÄ„Éü„Éº„Ç∑„Éº„ÇØ„É¨„ÉÉ„Éà**: http://$LB_IP/dummy-secret.txt" >> $GITHUB_STEP_SUMMARY
            LB_IP_PARTS=$(echo $LB_IP | tr '.' ' ')
            echo "- **Load Balancer IP**: $(echo $LB_IP_PARTS | sed 's/ /./g')" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "> üí° „Éñ„É©„Ç¶„Ç∂„Åß‰∏äË®ò IP „Å´„Ç¢„ÇØ„Çª„Çπ„Åß„Åç„Åæ„Åô" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Ingress „Éõ„Çπ„Éà**: \`$INGRESS_HOST\`" >> $GITHUB_STEP_SUMMARY
            echo "- **‚ö†Ô∏è Load Balancer IP ÂèñÂæóÂ§±Êïó**: „Åæ„Å† IP „ÅåÂâ≤„ÇäÂΩì„Å¶„Çâ„Çå„Å¶„ÅÑ„Å™„ÅÑÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "> üí° Êï∞ÂàÜÂæå„Å´ \`kubectl get svc -A | grep LoadBalancer\` „ÅßÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì¶ Pod Áä∂ÊÖã" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "```" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n "$BOARD_NS" -l app=board-app >> $GITHUB_STEP_SUMMARY
          echo "```" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üåê Ingress Áä∂ÊÖã" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "```" >> $GITHUB_STEP_SUMMARY
          kubectl get ingress -n "$BOARD_NS" >> $GITHUB_STEP_SUMMARY
          echo "```" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ „Éá„Éó„É≠„Ç§Êó•ÊôÇ: $(date +'%Y-%m-%d %H:%M:%S %Z')" >> $GITHUB_STEP_SUMMARY
