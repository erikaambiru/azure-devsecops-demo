name: 2️⃣ Board App Build & Deploy

on:
  workflow_dispatch:
    inputs:
      redeployTag:
        description: "ACR に既存タグがある場合に再デプロイする (空なら最新コミットをビルド)"
        required: false
      resourceGroupName:
        description: "既定値を上書きするデプロイ先のリソースグループ名"
        required: false
      aksClusterName:
        description: "既定値を上書きする AKS クラスター名"
        required: false
  push:
    branches:
      - master
    paths:
      - "app/board-app/**"
      - "app/board-api/**"
      - "app/board-app/k8s/**"
      - ".github/workflows/2-board-app-build-deploy.yml"
  workflow_run:
    workflows:
      - "1️⃣ Infrastructure Deploy"
    types:
      - completed

permissions:
  contents: read
  id-token: write
  security-events: write

env:
  RESOURCE_GROUP_NAME: ${{ github.event.inputs.resourceGroupName || vars.RESOURCE_GROUP_NAME }}
  AKS_CLUSTER_NAME: ${{ github.event.inputs.aksClusterName || vars.AKS_CLUSTER_NAME }}
  PARAM_FILE: infra/parameters/main-dev.parameters.json
  KUSTOMIZE_DIR: app/board-app/k8s
  ACR_NAME_PREFIX: ${{ vars.ACR_NAME_PREFIX }}
  STORAGE_ACCOUNT_PREFIX: ${{ vars.STORAGE_ACCOUNT_PREFIX }}
  BOARD_IMAGE_NAME: board-app
  BOARD_API_IMAGE_NAME: board-api
  DB_APP_USERNAME: ${{ vars.DB_APP_USERNAME }}
  DB_APP_PASSWORD: ${{ vars.DB_APP_PASSWORD }}
  GH_TOKEN: ${{ github.token }}

jobs:
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # 【準備フェーズ】デプロイコンテキスト収集
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # 目的: デプロイに必要な全コンテキスト情報を Azure から動的に収集・検証
  # 出力: ACR名、DB endpoint、Ingress IP、ノードRG、FQDN など
  # 依存: Azure CLI, jq, gh CLI
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  prepare-context:
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    outputs:
      checkout_ref: ${{ steps.detect_ref.outputs.checkout_ref }}
      image_tag: ${{ steps.detect_ref.outputs.image_tag }}
      build_required: ${{ steps.detect_ref.outputs.build_required }}
      acr_name: ${{ steps.resolve_acr.outputs.acr_name }}
      acr_login_server: ${{ steps.resolve_acr.outputs.acr_login_server }}
      resource_group_name: ${{ steps.resolve_rg.outputs.resource_group_name }}
      db_endpoint: ${{ steps.mysql_endpoint.outputs.db_endpoint }}
      aks_location: ${{ steps.aks_info.outputs.aks_location }}
      node_resource_group: ${{ steps.aks_info.outputs.node_resource_group }}
    env:
      REDEPLOY_TAG: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.redeployTag || '' }}
    steps:
      - name: コードを取得
        uses: actions/checkout@v4

      - name: ビルド対象コミットとタグを決定
        id: detect_ref
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            REF='${{ github.event.workflow_run.head_sha }}'
          else
            REF='${{ github.sha }}'
          fi
          BUILD_REQUIRED=true
          IMAGE_TAG=""
          if [ -n "${REDEPLOY_TAG}" ]; then
            BUILD_REQUIRED=false
            IMAGE_TAG="${REDEPLOY_TAG}"
          fi
          if [ -z "$IMAGE_TAG" ]; then
            SHORT_REF="${REF:0:12}"
            IMAGE_TAG="$SHORT_REF"
          fi
          echo "checkout_ref=$REF" >> "$GITHUB_OUTPUT"
          echo "image_tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          echo "build_required=$BUILD_REQUIRED" >> "$GITHUB_OUTPUT"
          echo "ターゲットコミット: $REF (tag=$IMAGE_TAG, build_required=$BUILD_REQUIRED)"

      - name: Azure に Service Principal でログイン
        uses: azure/login@v2
        with:
          creds: >-
            {"clientId":"${{ vars.AZURE_CLIENT_ID }}","tenantId":"${{ vars.AZURE_TENANT_ID }}","clientSecret":"${{ vars.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}"}

      - name: リソースグループを解決
        id: resolve_rg
        run: |
          set -euo pipefail
          RG_NAME="${RESOURCE_GROUP_NAME}"
          if [ -z "$RG_NAME" ]; then
            RG_NAME=$(jq -r '.parameters.resourceGroupName.value // empty' "$PARAM_FILE" || true)
          fi
          if [ -z "$RG_NAME" ]; then
            echo "ResourceGroup を特定できません" >&2
            exit 1
          fi
          if ! az group show --name "$RG_NAME" &>/dev/null; then
            echo "指定 RG ($RG_NAME) が存在しません" >&2
            az group list --query '[].name' -o tsv >&2 || true
            exit 2
          fi
          echo "resource_group_name=$RG_NAME" >> "$GITHUB_OUTPUT"

      - name: ACR 名を解決
        id: resolve_acr
        env:
          RESOLVED_RG: ${{ steps.resolve_rg.outputs.resource_group_name }}
        run: |
          set -euo pipefail
          if [ -z "$ACR_NAME_PREFIX" ] || [ -z "$RESOLVED_RG" ]; then
            echo "ACR を解決するための変数が不足しています" >&2
            exit 1
          fi
          ACR_NAME=$(az acr list --resource-group "$RESOLVED_RG" --query "[?starts_with(name, '${ACR_NAME_PREFIX}')].name | [0]" -o tsv)
          if [ -z "$ACR_NAME" ]; then
            echo "ACR が見つかりません。infra-deploy を先に実行してください" >&2
            exit 1
          fi
          echo "acr_name=$ACR_NAME" >> "$GITHUB_OUTPUT"
          echo "acr_login_server=${ACR_NAME}.azurecr.io" >> "$GITHUB_OUTPUT"
          echo "resource_group_name=$RESOLVED_RG" >> "$GITHUB_OUTPUT"

      - name: AKS メタデータを取得
        id: aks_info
        env:
          RESOLVED_RG: ${{ steps.resolve_rg.outputs.resource_group_name }}
        run: |
          set -euo pipefail
          if [ -z "$AKS_CLUSTER_NAME" ]; then
            echo "AKS クラスター名が未設定です" >&2
            exit 1
          fi
          AKS_JSON=$(az aks show --resource-group "$RESOLVED_RG" --name "$AKS_CLUSTER_NAME" 2>/dev/null || true)
          if [ -z "$AKS_JSON" ]; then
            echo "AKS クラスター $AKS_CLUSTER_NAME を RG=$RESOLVED_RG で取得できません" >&2
            exit 1
          fi

          # AKS メタデータから自動生成されたノードリソースグループ名を抽出
          # 例: MC_RG-demo-app1111_aks-demo-dev_japaneast
          NODE_RG=$(echo "$AKS_JSON" | jq -r '.nodeResourceGroup // empty')

          # AKS のデプロイリージョンを取得（Public IP 検索時のヒントとして利用）
          AKS_LOCATION=$(echo "$AKS_JSON" | jq -r '.location // empty')
          if [ -z "$NODE_RG" ]; then
            echo "AKS ノードリソースグループを解決できません" >&2
            exit 1
          fi
          
          # デバッグ出力: ノードリソースグループ名を確認
          echo "✅ 取得したノードリソースグループ: $NODE_RG"
          
          # ノードリソースグループの存在確認
          if ! az group show --name "$NODE_RG" &>/dev/null; then
            echo "⚠️ ノードリソースグループ '$NODE_RG' が存在しません" >&2
            echo "利用可能なリソースグループ一覧:" >&2
            az group list --query '[].name' -o tsv >&2
            exit 1
          fi
          
          echo "node_resource_group=$NODE_RG" >> "$GITHUB_OUTPUT"
          if [ -n "$AKS_LOCATION" ]; then
            echo "aks_location=$AKS_LOCATION" >> "$GITHUB_OUTPUT"
          fi

      - name: インフラ出力から MySQL Private IP を取得
        id: mysql_endpoint
        env:
          INFRA_WORKFLOW_NAME: "1️⃣ Infrastructure Deploy"
          RESOLVED_RG: ${{ steps.resolve_rg.outputs.resource_group_name }}
          NODE_RESOURCE_GROUP: ${{ steps.aks_info.outputs.node_resource_group }}
        run: |
          set -euo pipefail
          mkdir -p infra-output
          MYSQL_IP=""
          OUTPUT_FILE=""
          if [ "${{ github.event_name }}" = "workflow_run" ] && [ "${{ github.event.workflow_run.name }}" = "$INFRA_WORKFLOW_NAME" ]; then
            TARGET_RUN_ID='${{ github.event.workflow_run.id }}'
          else
            TARGET_RUN_ID=$(curl -s -H "Authorization: token $GH_TOKEN" \
              "https://api.github.com/repos/${{ github.repository }}/actions/workflows/1-infra-deploy.yml/runs?status=success&per_page=1" \
              | jq -r '.workflow_runs[0].id')
          fi
          if [ -n "$TARGET_RUN_ID" ] && [ "$TARGET_RUN_ID" != "null" ]; then
            if gh run download "$TARGET_RUN_ID" --name infra-outputs --dir infra-output >/dev/null 2>&1; then
              OUTPUT_FILE=$(find infra-output -name '*.json' | head -n1)
              if [ -n "$OUTPUT_FILE" ]; then
                # Bicep デプロイ出力から MySQL VM のプライベート IP を取得
                MYSQL_IP=$(jq -r '.mysqlPrivateIp.value // empty' "$OUTPUT_FILE")
              fi
            fi
          fi
          if [ -z "$MYSQL_IP" ]; then
            echo "infra-outputs から MySQL IP を取得できなかったため Azure リソースから解決します" >&2
            VM_NAME=$(jq -r '.parameters.vmName.value // empty' "$PARAM_FILE")
            if [ -z "$VM_NAME" ]; then
              echo "parameters ファイルに vmName が存在しません" >&2
              exit 1
            fi
            MYSQL_IP=$(az vm list-ip-addresses --resource-group "$RESOLVED_RG" --name "$VM_NAME" --query "[0].virtualMachine.network.privateIpAddresses[0]" -o tsv || true)
          fi
          MYSQL_PORT=$(jq -r '.parameters.mysqlPort.value // 3306' "$PARAM_FILE")
          if [ -z "$MYSQL_IP" ] || [ "$MYSQL_IP" = "null" ]; then
            echo "MySQL Private IP を Azure から取得できませんでした" >&2
            exit 1
          fi
          echo "db_endpoint=${MYSQL_IP}:${MYSQL_PORT}" >> "$GITHUB_OUTPUT"
          echo "Resolved MySQL endpoint: ${MYSQL_IP}:${MYSQL_PORT}"

  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # 【セキュリティフェーズ】ソースコード脆弱性スキャン
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # 目的: ソースコードとコンテナイメージの脆弱性・秘密情報を検出
  # ツール: Trivy (FS/Image scan), Gitleaks (secret detection)
  # 成果物: SARIF レポート → GitHub Security タブに自動アップロード
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  code-security-scans:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write # SARIF アップロードで必要
    needs: prepare-context
    # 実行条件: ビルドが必要な場合のみ（再デプロイ時はスキップ）
    if: ${{ needs.prepare-context.outputs.build_required == 'true' }}
    outputs:
      gitleaks_issues: ${{ steps.scan_summary.outputs.gitleaks_issues }}
      trivy_fs_critical: ${{ steps.scan_summary.outputs.trivy_fs_critical }}
      trivy_fs_high: ${{ steps.scan_summary.outputs.trivy_fs_high }}
    steps:
      - name: コードを取得
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-context.outputs.checkout_ref }}

      - name: Gitleaks で秘密情報を検出
        continue-on-error: true
        run: |
          set +e
          VERSION="8.18.4"
          curl -sSL "https://github.com/gitleaks/gitleaks/releases/download/v${VERSION}/gitleaks_${VERSION}_linux_x64.tar.gz" -o gitleaks.tgz
          tar -xzf gitleaks.tgz gitleaks
          sudo install -m 755 gitleaks /usr/local/bin/gitleaks
          gitleaks detect --no-banner --report-format sarif --report-path gitleaks-board.sarif
          echo "Gitleaks completed (exit code=$?)"

      - name: ソース/設定/シークレット総合スキャン (Trivy FS)
        continue-on-error: true
        run: |
          set -euo pipefail
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b ./trivy-bin
          ./trivy-bin fs --scanners vuln,secret,config --ignore-unfixed --severity CRITICAL,HIGH \
            --format sarif --output trivy-fs-board.sarif app/board-app || echo "脆弱性検出あり"

      - name: Trivy FS レポートを保証
        if: always()
        run: |
          set -euo pipefail
          if [ ! -f trivy-fs-board.sarif ]; then
            MESSAGE="Trivy FS が失敗/結果なしでも SARIF を欠かさずアップロードするため空ファイルを生成しました (Board App)"
            echo "$MESSAGE"
            printf '%s\n' \
              '{' \
              '  "version": "2.1.0",' \
              '  "runs": [' \
              '    {' \
              '      "tool": {' \
              '        "driver": {' \
              '          "name": "trivy",' \
              '          "informationUri": "https://github.com/aquasecurity/trivy"' \
              '        }' \
              '      },' \
              '      "results": []' \
              '    }' \
              '  ]' \
              '}' > trivy-fs-board.sarif
            if [ -n "${GITHUB_STEP_SUMMARY:-}" ]; then
              {
                echo "### Trivy FS フォールバック (Board App)"
                echo "- $MESSAGE"
                echo "- レポート: \`trivy-fs-board.sarif\`"
              } >> "$GITHUB_STEP_SUMMARY"
            fi
          fi

      - name: Trivy SARIF をアップロード (FS)
        if: always()
        continue-on-error: true
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: trivy-fs-board.sarif
          category: board-app-trivy-fs

      - name: Gitleaks SARIF をアップロード
        if: always()
        continue-on-error: true
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: gitleaks-board.sarif
          category: board-app-gitleaks

      - name: セキュリティスキャン結果を集計
        id: scan_summary
        if: always()
        run: |
          set +e
          # Gitleaks結果
          GITLEAKS_ISSUES=0
          if [ -f gitleaks-board.sarif ]; then
            GITLEAKS_ISSUES=$(jq '[.runs[].results // []] | add | length' gitleaks-board.sarif 2>/dev/null || echo "0")
          fi
          echo "gitleaks_issues=$GITLEAKS_ISSUES" >> "$GITHUB_OUTPUT"

          # Trivy FS結果
          TRIVY_FS_CRITICAL=0
          TRIVY_FS_HIGH=0
          if [ -f trivy-fs-board.sarif ]; then
            TRIVY_FS_CRITICAL=$(jq '[.runs[].results[] | select(.level == "error")] | length' trivy-fs-board.sarif 2>/dev/null || echo "0")
            TRIVY_FS_HIGH=$(jq '[.runs[].results[] | select(.level == "warning")] | length' trivy-fs-board.sarif 2>/dev/null || echo "0")
          fi
          echo "trivy_fs_critical=$TRIVY_FS_CRITICAL" >> "$GITHUB_OUTPUT"
          echo "trivy_fs_high=$TRIVY_FS_HIGH" >> "$GITHUB_OUTPUT"

  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # 【ビルドフェーズ】コンテナイメージビルド & ACR プッシュ
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # 目的: Board App/API のコンテナイメージをビルドして ACR にプッシュ
  # セキュリティ: Trivy でイメージスキャン、SBOM 生成
  # 成果物: コンテナイメージ、SBOM (CycloneDX)、SARIF レポート
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write # SARIF アップロードで必要
    needs:
      - prepare-context
      - code-security-scans
    # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    # 実行条件:
    #   - prepare-context が成功
    #   AND
    #   - code-security-scans が成功 OR スキップ（再デプロイ時）
    # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    if: ${{ needs.prepare-context.result == 'success' && (needs.code-security-scans.result == 'success' || needs.code-security-scans.result == 'skipped') }}
    outputs:
      image_tag: ${{ steps.metadata.outputs.image_tag }}
      board_image_full: ${{ steps.metadata.outputs.board_image_full }}
      board_api_image_full: ${{ steps.metadata.outputs.board_api_image_full }}
      board_image_critical: ${{ steps.image_scan_summary.outputs.board_image_critical }}
      board_image_high: ${{ steps.image_scan_summary.outputs.board_image_high }}
      api_image_critical: ${{ steps.image_scan_summary.outputs.api_image_critical }}
      api_image_high: ${{ steps.image_scan_summary.outputs.api_image_high }}
    env:
      CHECKOUT_REF: ${{ needs.prepare-context.outputs.checkout_ref }}
      IMAGE_TAG: ${{ needs.prepare-context.outputs.image_tag }}
      ACR_NAME: ${{ needs.prepare-context.outputs.acr_name }}
      ACR_LOGIN_SERVER: ${{ needs.prepare-context.outputs.acr_login_server }}
      BUILD_REQUIRED: ${{ needs.prepare-context.outputs.build_required }}
    steps:
      - name: コードを取得
        uses: actions/checkout@v4
        with:
          ref: ${{ env.CHECKOUT_REF }}

      - name: メタデータをエクスポート
        id: metadata
        run: |
          IMAGE_FULL="$ACR_LOGIN_SERVER/$BOARD_IMAGE_NAME:$IMAGE_TAG"
          BOARD_API_IMAGE_FULL="$ACR_LOGIN_SERVER/$BOARD_API_IMAGE_NAME:$IMAGE_TAG"
          echo "image_tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          echo "board_image_full=$IMAGE_FULL" >> "$GITHUB_OUTPUT"
          echo "board_api_image_full=$BOARD_API_IMAGE_FULL" >> "$GITHUB_OUTPUT"
          echo "IMAGE_FULL=$IMAGE_FULL" >> "$GITHUB_ENV"
          echo "BOARD_API_IMAGE_FULL=$BOARD_API_IMAGE_FULL" >> "$GITHUB_ENV"

      - name: Azure に Service Principal でログイン
        if: ${{ env.BUILD_REQUIRED == 'true' }}
        uses: azure/login@v2
        with:
          creds: >-
            {"clientId":"${{ vars.AZURE_CLIENT_ID }}","tenantId":"${{ vars.AZURE_TENANT_ID }}","clientSecret":"${{ vars.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}"}

      - name: ACR 管理者認証を有効化
        if: ${{ env.BUILD_REQUIRED == 'true' }}
        run: az acr update --name "$ACR_NAME" --admin-enabled true

      - name: ACR 管理者資格情報を取得
        if: ${{ env.BUILD_REQUIRED == 'true' }}
        id: acr_creds
        run: |
          set -euo pipefail
          USERNAME=$(az acr credential show --name "$ACR_NAME" --query username -o tsv)
          PASSWORD=$(az acr credential show --name "$ACR_NAME" --query "passwords[0].value" -o tsv)
          echo "::add-mask::$PASSWORD"
          echo "username=$USERNAME" >> "$GITHUB_OUTPUT"
          echo "password=$PASSWORD" >> "$GITHUB_OUTPUT"

      - name: Docker にログイン (ACR)
        if: ${{ env.BUILD_REQUIRED == 'true' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.ACR_LOGIN_SERVER }}
          username: ${{ steps.acr_creds.outputs.username }}
          password: ${{ steps.acr_creds.outputs.password }}

      - name: Docker Buildx をセットアップ
        if: ${{ env.BUILD_REQUIRED == 'true' }}
        uses: docker/setup-buildx-action@v3

      - name: Board App イメージをビルド&プッシュ (キャッシュ有効)
        if: ${{ env.BUILD_REQUIRED == 'true' }}
        uses: docker/build-push-action@v5
        with:
          context: app/board-app
          file: app/board-app/Dockerfile
          push: true
          tags: |
            ${{ steps.metadata.outputs.board_image_full }}
            ${{ env.ACR_LOGIN_SERVER }}/${{ env.BOARD_IMAGE_NAME }}:latest
          cache-from: type=gha,scope=board-app
          cache-to: type=gha,scope=board-app,mode=max

      - name: Board API イメージをビルド&プッシュ (キャッシュ有効)
        if: ${{ env.BUILD_REQUIRED == 'true' }}
        uses: docker/build-push-action@v5
        with:
          context: app/board-api
          file: app/board-api/Dockerfile
          push: true
          tags: |
            ${{ steps.metadata.outputs.board_api_image_full }}
            ${{ env.ACR_LOGIN_SERVER }}/${{ env.BOARD_API_IMAGE_NAME }}:latest
          cache-from: type=gha,scope=board-api
          cache-to: type=gha,scope=board-api,mode=max

      - name: Trivy DB キャッシュ復元
        if: ${{ env.BUILD_REQUIRED == 'true' }}
        uses: actions/cache@v4
        with:
          path: ~/.cache/trivy
          key: trivy-db-${{ runner.os }}-${{ hashFiles('app/board-app/package.json') }}
          restore-keys: |
            trivy-db-${{ runner.os }}-

      - name: コンテナ SBOM 生成 (Board)
        if: ${{ env.BUILD_REQUIRED == 'true' }}
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ steps.metadata.outputs.board_image_full }}
          format: "cyclonedx"
          output: "sbom-board.cdx.json"
          hide-progress: true
          ignore-unfixed: true
          vuln-type: "os,library"
          severity: "CRITICAL,HIGH"
          exit-code: "0"

      - name: コンテナ SBOM 生成 (Board API)
        if: ${{ env.BUILD_REQUIRED == 'true' }}
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ steps.metadata.outputs.board_api_image_full }}
          format: "cyclonedx"
          output: "sbom-board-api.cdx.json"
          hide-progress: true
          ignore-unfixed: true
          vuln-type: "os,library"
          severity: "CRITICAL,HIGH"
          exit-code: "0"

      - name: Trivy でコンテナをスキャン (Board)
        if: ${{ env.BUILD_REQUIRED == 'true' }}
        uses: aquasecurity/trivy-action@0.28.0
        continue-on-error: true
        with:
          image-ref: ${{ steps.metadata.outputs.board_image_full }}
          format: "sarif"
          output: "trivy-image-board.sarif"
          hide-progress: true
          ignore-unfixed: true
          vuln-type: "os,library"
          severity: "CRITICAL,HIGH"
          exit-code: "0"

      - name: Trivy でコンテナをスキャン (Board API)
        if: ${{ env.BUILD_REQUIRED == 'true' }}
        uses: aquasecurity/trivy-action@0.28.0
        continue-on-error: true
        with:
          image-ref: ${{ steps.metadata.outputs.board_api_image_full }}
          format: "sarif"
          output: "trivy-image-board-api.sarif"
          hide-progress: true
          ignore-unfixed: true
          vuln-type: "os,library"
          severity: "CRITICAL,HIGH"
          exit-code: "0"

      - name: Trivy SARIF をアップロード
        if: ${{ env.BUILD_REQUIRED == 'true' && always() }}
        continue-on-error: true
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: trivy-image-board.sarif
          category: board-app-trivy-image

      - name: Trivy SARIF (Board API) をアップロード
        if: ${{ env.BUILD_REQUIRED == 'true' && always() }}
        continue-on-error: true
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: trivy-image-board-api.sarif
          category: board-api-trivy-image

      - name: コンテナイメージスキャン結果を集計
        id: image_scan_summary
        if: ${{ env.BUILD_REQUIRED == 'true' && always() }}
        run: |
          set +e
          # Trivy Image (Board) 結果
          BOARD_IMAGE_CRITICAL=0
          BOARD_IMAGE_HIGH=0
          if [ -f trivy-image-board.sarif ]; then
            BOARD_IMAGE_CRITICAL=$(jq '[.runs[].results[] | select(.level == "error")] | length' trivy-image-board.sarif 2>/dev/null || echo "0")
            BOARD_IMAGE_HIGH=$(jq '[.runs[].results[] | select(.level == "warning")] | length' trivy-image-board.sarif 2>/dev/null || echo "0")
          fi
          echo "board_image_critical=$BOARD_IMAGE_CRITICAL" >> "$GITHUB_OUTPUT"
          echo "board_image_high=$BOARD_IMAGE_HIGH" >> "$GITHUB_OUTPUT"

          # Trivy Image (Board API) 結果
          API_IMAGE_CRITICAL=0
          API_IMAGE_HIGH=0
          if [ -f trivy-image-board-api.sarif ]; then
            API_IMAGE_CRITICAL=$(jq '[.runs[].results[] | select(.level == "error")] | length' trivy-image-board-api.sarif 2>/dev/null || echo "0")
            API_IMAGE_HIGH=$(jq '[.runs[].results[] | select(.level == "warning")] | length' trivy-image-board-api.sarif 2>/dev/null || echo "0")
          fi
          echo "api_image_critical=$API_IMAGE_CRITICAL" >> "$GITHUB_OUTPUT"
          echo "api_image_high=$API_IMAGE_HIGH" >> "$GITHUB_OUTPUT"

      - name: 成果メタデータを保存
        if: ${{ env.BUILD_REQUIRED == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: board-app-image
          path: |
            sbom-board.cdx.json
            sbom-board-api.cdx.json
            trivy-image-board.sarif
            trivy-image-board-api.sarif

  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # 【デプロイフェーズ】AKS へのアプリケーションデプロイ
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  # 目的: Board App/API を AKS にデプロイし、Ingress 経由で公開
  # 処理:
  #   1. NGINX Ingress Controller インストール/更新
  #   2. LoadBalancer IP 割り当て待機
  #   3. Board App/API Deployment 適用
  #   4. ヘルスチェック & 接続確認
  # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  deploy:
    runs-on: ubuntu-latest
    needs:
      - prepare-context
      - code-security-scans
      - build-and-push
    # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    # 実行条件:
    #   - prepare-context が成功
    #   AND
    #   - build-and-push が成功 OR スキップ（既存イメージ使用時）
    # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    if: ${{ needs.prepare-context.result == 'success' && (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'skipped') }}
    env:
      RESOURCE_GROUP_NAME: ${{ needs.prepare-context.outputs.resource_group_name }}
      ACR_NAME: ${{ needs.prepare-context.outputs.acr_name }}
      ACR_LOGIN_SERVER: ${{ needs.prepare-context.outputs.acr_login_server }}
      DB_ENDPOINT: ${{ needs.prepare-context.outputs.db_endpoint }}
      IMAGE_TAG: ${{ needs.build-and-push.outputs.image_tag || needs.prepare-context.outputs.image_tag }}
      CHECKOUT_REF: ${{ needs.prepare-context.outputs.checkout_ref }}
      NODE_RESOURCE_GROUP: ${{ needs.prepare-context.outputs.node_resource_group }}
    steps:
      - name: コードを取得
        uses: actions/checkout@v4
        with:
          ref: ${{ env.CHECKOUT_REF }}

      - name: Azure に Service Principal でログイン
        uses: azure/login@v2
        with:
          creds: >-
            {"clientId":"${{ vars.AZURE_CLIENT_ID }}","tenantId":"${{ vars.AZURE_TENANT_ID }}","clientSecret":"${{ vars.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}"}

      - name: kubectl を準備
        run: az aks install-cli

      - name: Namespace/Ingress の値を同期
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          & ./scripts/sync-board-vars.ps1 `
            -ParametersFile "infra/parameters/main-dev.parameters.json" `
            -OutputFile "app/board-app/k8s/vars.env"

      - name: AKS 資格情報を取得
        run: |
          az aks get-credentials \
            --name "$AKS_CLUSTER_NAME" \
            --resource-group "$RESOURCE_GROUP_NAME" \
            --overwrite-existing

      - name: AKS クラスターの状態を確認
        run: |
          set -euo pipefail
          
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "🔍 AKS クラスター状態確認"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          
          # AKS クラスター情報を取得
          AKS_INFO=$(az aks show \
            --resource-group "$RESOURCE_GROUP_NAME" \
            --name "$AKS_CLUSTER_NAME" \
            --query '{
              provisioningState: provisioningState,
              powerState: powerState.code,
              fqdn: fqdn,
              privateFqdn: privateFqdn,
              kubernetesVersion: kubernetesVersion
            }' \
            -o json)
          
          echo "AKS クラスター情報:"
          echo "$AKS_INFO" | jq '.'
          
          POWER_STATE=$(echo "$AKS_INFO" | jq -r '.powerState // "Unknown"')
          PROVISIONING_STATE=$(echo "$AKS_INFO" | jq -r '.provisioningState // "Unknown"')
          FQDN=$(echo "$AKS_INFO" | jq -r '.fqdn // "Unknown"')
          
          echo ""
          echo "プロビジョニング状態: $PROVISIONING_STATE"
          echo "電源状態: $POWER_STATE"
          echo "FQDN: $FQDN"
          
          # クラスターが停止している場合は開始
          if [ "$POWER_STATE" = "Stopped" ]; then
            echo ""
            echo "⚠️ AKS クラスターが停止中です。起動を開始します..."
            az aks start \
              --resource-group "$RESOURCE_GROUP_NAME" \
              --name "$AKS_CLUSTER_NAME" \
              --no-wait
            
            echo "⏳ クラスターの起動を待機しています（最大 10 分）..."
            
            # 起動完了を待機（最大 10 分）
            MAX_WAIT_SECONDS=600
            WAIT_INTERVAL=15
            ELAPSED=0
            
            while [ $ELAPSED -lt $MAX_WAIT_SECONDS ]; do
              CURRENT_POWER_STATE=$(az aks show \
                --resource-group "$RESOURCE_GROUP_NAME" \
                --name "$AKS_CLUSTER_NAME" \
                --query 'powerState.code' -o tsv)
              
              if [ "$CURRENT_POWER_STATE" = "Running" ]; then
                echo "✅ AKS クラスターが起動しました"
                break
              fi
              
              echo "  現在の状態: $CURRENT_POWER_STATE （経過: ${ELAPSED}秒/${MAX_WAIT_SECONDS}秒）"
              sleep $WAIT_INTERVAL
              ELAPSED=$((ELAPSED + WAIT_INTERVAL))
            done
            
            if [ "$CURRENT_POWER_STATE" != "Running" ]; then
              echo "❌ AKS クラスターの起動がタイムアウトしました" >&2
              exit 1
            fi
            
            # 起動後、DNS が伝播するまで追加で待機
            echo "⏳ DNS 伝播を待機しています（30秒）..."
            sleep 30
          elif [ "$POWER_STATE" != "Running" ]; then
            echo "❌ AKS クラスターが予期しない状態です: $POWER_STATE" >&2
            exit 1
          else
            echo "✅ AKS クラスターは実行中です"
          fi
          
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

      - name: AKS 接続を検証
        env:
          # DNS 解決リトライ設定（DNS 伝播遅延に対応するため）
          MAX_DNS_RETRIES: "5"  # 最大 5 回まで試行
          DNS_RETRY_INTERVAL: "10"  # 10 秒間隔でリトライ
          # クラスター接続リトライ設定（一時的なネットワーク問題に対応するため）
          MAX_CLUSTER_RETRIES: "3"  # 最大 3 回まで試行
          CLUSTER_RETRY_INTERVAL: "5"  # 5 秒間隔でリトライ
        run: |
          set -euo pipefail
          
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "🔍 AKS 接続検証"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          
          echo ""
          echo "=== 1. kubeconfig の確認 ==="
          kubectl config view --minify
          
          echo ""
          echo "=== 2. API サーバーエンドポイントの確認 ==="
          API_SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')
          echo "API Server: $API_SERVER"
          
          echo ""
          echo "=== 3. DNS 解決テスト ==="
          API_HOST=$(echo "$API_SERVER" | sed 's|https://||' | sed 's|:.*||')
          echo "Hostname: $API_HOST"
          
          # DNS 解決を複数回リトライ（DNS 伝播待ち）
          DNS_RESOLVED=false
          
          for i in $(seq 1 $MAX_DNS_RETRIES); do
            echo "DNS 解決試行 [$i/$MAX_DNS_RETRIES]"
            if nslookup "$API_HOST"; then
              DNS_RESOLVED=true
              echo "✅ DNS 解決成功"
              break
            fi
            if [ $i -lt $MAX_DNS_RETRIES ]; then
              echo "⏳ DNS 伝播を待機中... (${DNS_RETRY_INTERVAL}秒)"
              sleep $DNS_RETRY_INTERVAL
            fi
          done
          
          if [ "$DNS_RESOLVED" != "true" ]; then
            echo "❌ DNS 解決に失敗しました" >&2
            echo ""
            echo "考えられる原因:" >&2
            echo "1. AKS クラスターが削除または再作成されている" >&2
            echo "2. DNS の伝播に時間がかかっている（通常は起動後 1-2 分）" >&2
            echo "3. ネットワーク構成に問題がある" >&2
            echo ""
            echo "=== Azure AKS クラスター詳細情報 ===" >&2
            az aks show \
              --resource-group "$RESOURCE_GROUP_NAME" \
              --name "$AKS_CLUSTER_NAME" \
              --query '{
                id: id,
                provisioningState: provisioningState,
                powerState: powerState.code,
                fqdn: fqdn,
                privateFqdn: privateFqdn,
                kubernetesVersion: kubernetesVersion,
                networkProfile: networkProfile.networkPlugin,
                apiServerAccessProfile: apiServerAccessProfile
              }' \
              -o json >&2 || echo "AKS クラスター情報の取得に失敗しました" >&2
            echo ""
            echo "=== /etc/resolv.conf の内容 ===" >&2
            cat /etc/resolv.conf >&2
            echo ""
            echo "=== Google DNS テスト（DNS サーバー自体の動作確認）===" >&2
            nslookup google.com >&2 || true
            echo ""
            echo "推奨対応:" >&2
            echo "- AKS クラスターが起動するまで 1-2 分待ってから再試行してください" >&2
            echo "- Azure Portal で AKS クラスターの状態を確認してください" >&2
            echo "- 必要に応じて Infrastructure Deploy ワークフローを再実行してください" >&2
            exit 1
          fi
          
          echo ""
          echo "=== 4. クラスター接続テスト ==="
          # クラスター接続も複数回リトライ
          CLUSTER_CONNECTED=false
          
          for i in $(seq 1 $MAX_CLUSTER_RETRIES); do
            echo "クラスター接続試行 [$i/$MAX_CLUSTER_RETRIES]"
            if kubectl cluster-info; then
              CLUSTER_CONNECTED=true
              echo "✅ クラスター接続成功"
              break
            fi
            if [ $i -lt $MAX_CLUSTER_RETRIES ]; then
              echo "⏳ リトライ待機中... (${CLUSTER_RETRY_INTERVAL}秒)"
              sleep $CLUSTER_RETRY_INTERVAL
            fi
          done
          
          if [ "$CLUSTER_CONNECTED" != "true" ]; then
            echo "❌ クラスターへの接続に失敗しました" >&2
            echo ""
            echo "=== kubectl バージョン ===" >&2
            kubectl version --client >&2 || true
            echo ""
            echo "=== Azure AKS 診断情報 ===" >&2
            az aks show \
              --resource-group "$RESOURCE_GROUP_NAME" \
              --name "$AKS_CLUSTER_NAME" \
              --query '{
                provisioningState: provisioningState,
                powerState: powerState.code,
                fqdn: fqdn,
                privateFqdn: privateFqdn,
                apiServerAccessProfile: apiServerAccessProfile
              }' \
              -o json >&2 || true
            exit 1
          fi
          
          echo ""
          echo "=== 5. ノード一覧の取得 ==="
          kubectl get nodes -o wide
          
          echo ""
          echo "✅ AKS 接続検証完了"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

      - name: NSG に Load Balancer 通信用ルールを適用
        run: |
          set -euo pipefail
          NODE_RG="${NODE_RESOURCE_GROUP}"
          NSG_NAME=$(az network nsg list --resource-group "$NODE_RG" --query "[?contains(name, 'aks-agentpool')].name | [0]" -o tsv)
          if [ -z "$NSG_NAME" ]; then
            echo "NSG が見つかりません: rg=$NODE_RG" >&2
            exit 1
          fi
          ensure_rule() {
            local rule_name=$1
            local source_prefix=$2
            local ports=$3
            local priority=$4
            if az network nsg rule show --resource-group "$NODE_RG" --nsg-name "$NSG_NAME" --name "$rule_name" &>/dev/null; then
              az network nsg rule update --resource-group "$NODE_RG" --nsg-name "$NSG_NAME" --name "$rule_name" \
                --source-address-prefixes "$source_prefix" --destination-port-ranges "$ports" \
                --access Allow --direction Inbound --protocol Tcp --priority "$priority" >/dev/null
            else
              az network nsg rule create --resource-group "$NODE_RG" --nsg-name "$NSG_NAME" --name "$rule_name" \
                --source-address-prefixes "$source_prefix" --destination-port-ranges "$ports" \
                --access Allow --direction Inbound --protocol Tcp --priority "$priority" >/dev/null
            fi
          }
          ensure_rule "allow-azure-lb-probes" AzureLoadBalancer 30000-32767 300
          ensure_rule "allow-nodeport-from-internet" Internet 30000-32767 310

      - name: Ingress Controller (nginx) を確認/インストール
        env:
          NODE_RESOURCE_GROUP: ${{ env.NODE_RESOURCE_GROUP }}
        run: |
          set -euo pipefail
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx || true
          helm repo update
          INGRESS_APP_VERSION=$(helm show chart ingress-nginx/ingress-nginx | awk -F': ' '/^appVersion:/ {print $2}' | tr -d '[:space:]')
          if [ -z "$INGRESS_APP_VERSION" ] || [ "$INGRESS_APP_VERSION" = "null" ]; then
            echo "appVersion を取得できません" >&2
            exit 1
          fi
          if [[ "$INGRESS_APP_VERSION" == v* ]]; then
            CONTROLLER_TAG="$INGRESS_APP_VERSION"
          else
            CONTROLLER_TAG="v${INGRESS_APP_VERSION}"
          fi
          CONTROLLER_IMAGE="ingress-nginx/controller"
          export CONTROLLER_IMAGE CONTROLLER_TAG
          az acr import --name "$ACR_NAME" --source "registry.k8s.io/${CONTROLLER_IMAGE}:${CONTROLLER_TAG}" --image "${CONTROLLER_IMAGE}:${CONTROLLER_TAG}" --force || \
            az acr import --name "$ACR_NAME" --source "mcr.microsoft.com/oss/kubernetes/${CONTROLLER_IMAGE}:${CONTROLLER_TAG}" --image "${CONTROLLER_IMAGE}:${CONTROLLER_TAG}" --force

          VALUES_FILE="app/board-app/k8s/ingress-nginx-values.yaml"
          OVERRIDE_FILE=$(mktemp)
          export OVERRIDE_FILE

          # 固定 Public IP 指定を削除し、AKS に自動作成させる
          # 理由: 指定した IP が存在しないと LoadBalancer が <pending> のまま固まる
          python -c 'import os, pathlib; content = "controller:\n  image:\n    registry: \"{ACR_LOGIN_SERVER}\"\n    image: \"{CONTROLLER_IMAGE}\"\n    tag: \"{CONTROLLER_TAG}\"\n  service:\n    annotations:\n      service.beta.kubernetes.io/azure-load-balancer-resource-group: \"{NODE_RESOURCE_GROUP}\"\n".format(**os.environ); pathlib.Path(os.environ["OVERRIDE_FILE"]).write_text(content)'

          # Namespace を事前作成（冪等性を確保）
          kubectl create namespace ingress-nginx --dry-run=client -o yaml | kubectl apply -f -

          # 固まっている Helm Release を強制的にクリーンアップ
          # pending-install, pending-upgrade, failed 状態の場合は即座に削除
          if helm list -n ingress-nginx | grep -q ingress-nginx; then
            HELM_STATUS=$(helm status ingress-nginx -n ingress-nginx -o json 2>/dev/null | jq -r '.info.status // empty' || echo "unknown")
            echo "現在の Helm リリース状態: $HELM_STATUS"
            
            if [ "$HELM_STATUS" = "pending-install" ] || [ "$HELM_STATUS" = "pending-upgrade" ] || [ "$HELM_STATUS" = "failed" ]; then
              echo "⚠️ Helm Release が ${HELM_STATUS} 状態です。強制クリーンアップを実行します..."
              helm uninstall ingress-nginx -n ingress-nginx --wait --timeout=2m || true
              sleep 10
              echo "✅ Helm Release をクリーンアップしました"
            fi
          fi

          # helm upgrade --install --atomic で冪等にインストール/アップグレード
          # --atomic: 失敗時に自動ロールバック、Service 削除なしで安全に更新
          # --cleanup-on-fail: 失敗時のリソースクリーンアップ
          if ! helm upgrade ingress-nginx ingress-nginx/ingress-nginx \
            --install \
            --namespace ingress-nginx \
            --create-namespace \
            --values "$VALUES_FILE" \
            --values "$OVERRIDE_FILE" \
            --atomic \
            --cleanup-on-fail \
            --wait \
            --timeout=15m; then
            
            echo "⚠️ Helm upgrade が失敗しました。デバッグ情報を収集します..." >&2
            
            # デバッグ情報収集
            echo "--- Webhook 設定 ---"
            kubectl get validatingwebhookconfigurations | grep ingress-nginx || true
            
            echo "--- Ingress Nginx リソース ---"
            kubectl -n ingress-nginx get svc,deploy,po || true
            
            echo "--- 最新イベント ---"
            kubectl -n ingress-nginx get events --sort-by=.metadata.creationTimestamp | tail -30 || true
            
            echo "--- Service 詳細 ---"
            kubectl -n ingress-nginx describe svc ingress-nginx-controller || true
            kubectl -n ingress-nginx describe svc ingress-nginx-controller-admission || true
            
            echo "--- Helm リリース状態 ---"
            helm list -n ingress-nginx || true
            helm history ingress-nginx -n ingress-nginx || true
            
            exit 1
          fi

          rm -f "$OVERRIDE_FILE"

          kubectl rollout status deployment/ingress-nginx-controller -n ingress-nginx --timeout=600s

          # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
          # LoadBalancer IP 割り当て待機
          # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
          readonly LB_IP_TIMEOUT_MINUTES=12
          readonly LB_IP_POLL_INTERVAL=10
          LB_IP_ATTEMPTS=$((LB_IP_TIMEOUT_MINUTES * 60 / LB_IP_POLL_INTERVAL))

          for i in $(seq 1 $LB_IP_ATTEMPTS); do
            LB_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
            if [ -n "$LB_IP" ]; then
              echo "ACTUAL_LB_IP=$LB_IP" >> "$GITHUB_ENV"
              echo "✅ LoadBalancer IP を取得: $LB_IP"
              break
            fi
            echo "[$i/$LB_IP_ATTEMPTS] LoadBalancer IP 割り当て待機中... (最大${LB_IP_TIMEOUT_MINUTES}分)"
            sleep $LB_IP_POLL_INTERVAL
          done

          if [ -z "${LB_IP:-}" ]; then
            echo "❌ LoadBalancer IP が割り当てられませんでした" >&2
            kubectl get svc -n ingress-nginx ingress-nginx-controller
            exit 1
          fi

      - name: LoadBalancer 健康チェック
        run: |
          set -euo pipefail
          LB_IP=${ACTUAL_LB_IP:-}
          if [ -z "$LB_IP" ]; then
            echo "LoadBalancer IP が取得できません" >&2
            exit 1
          fi

          # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
          # Ingress Controller ヘルスチェック (/healthz エンドポイント確認)
          # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
          echo "LoadBalancer ($LB_IP) のヘルスプローブを検証します"

          readonly HEALTH_CHECK_TIMEOUT_MINUTES=3
          readonly HEALTH_CHECK_INTERVAL=5
          HEALTH_CHECK_ATTEMPTS=$((HEALTH_CHECK_TIMEOUT_MINUTES * 60 / HEALTH_CHECK_INTERVAL))
          HEALTH_CHECK_SUCCESS=false

          for i in $(seq 1 $HEALTH_CHECK_ATTEMPTS); do
            if kubectl exec -n ingress-nginx deployment/ingress-nginx-controller -- curl -s -o /dev/null -w "%{http_code}" http://localhost:10254/healthz | grep -q "200"; then
              echo "✅ [$i/$HEALTH_CHECK_ATTEMPTS] Ingress Controller ヘルスチェック成功"
              HEALTH_CHECK_SUCCESS=true
              break
            fi
            echo "[$i/$HEALTH_CHECK_ATTEMPTS] ヘルスチェック待機中... (最大${HEALTH_CHECK_TIMEOUT_MINUTES}分)"
            sleep $HEALTH_CHECK_INTERVAL
          done

          if [ "$HEALTH_CHECK_SUCCESS" != "true" ]; then
            echo "⚠️ ヘルスチェックが成功しませんでしたが、続行します" >&2
            kubectl get pods -n ingress-nginx
            kubectl logs -n ingress-nginx deployment/ingress-nginx-controller --tail=50 || true
          fi

          NODE_RG="${NODE_RESOURCE_GROUP}"
          if [ -n "$NODE_RG" ]; then
            PROBE_INFO=$(az network lb probe list --resource-group "$NODE_RG" --lb-name kubernetes --query "[].{Name:name,Port:port}" -o json 2>/dev/null || echo "[]")
            echo "現在のヘルスプローブ:" && echo "$PROBE_INFO" | jq '.'
          fi

          # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
          # LoadBalancer ポート 80 接続確認（外部からの疎通テスト）
          # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
          readonly CONNECTIVITY_TIMEOUT_MINUTES=6
          readonly CONNECTIVITY_INTERVAL=10
          CONNECTIVITY_ATTEMPTS=$((CONNECTIVITY_TIMEOUT_MINUTES * 60 / CONNECTIVITY_INTERVAL))
          CONNECTIVITY_SUCCESS=false

          for i in $(seq 1 $CONNECTIVITY_ATTEMPTS); do
            if timeout 5 bash -c "echo > /dev/tcp/$LB_IP/80" 2>/dev/null; then
              echo "✅ [$i/$CONNECTIVITY_ATTEMPTS] LoadBalancer ポート 80 への接続成功"
              CONNECTIVITY_SUCCESS=true
              break
            fi
            echo "[$i/$CONNECTIVITY_ATTEMPTS] LoadBalancer ポート 80 接続待機中... (最大${CONNECTIVITY_TIMEOUT_MINUTES}分)"
            sleep $CONNECTIVITY_INTERVAL
          done

          if [ "$CONNECTIVITY_SUCCESS" != "true" ]; then
            echo "⚠️ LoadBalancer ポート 80 への接続が確認できませんでしたが、続行します" >&2
            az network lb probe list --resource-group "$NODE_RG" --lb-name kubernetes -o table || true
          fi

      - name: ACR Pull 権限を再確認
        run: |
          if az aks check-acr --name "$AKS_CLUSTER_NAME" --resource-group "$RESOURCE_GROUP_NAME" --acr "$ACR_LOGIN_SERVER" &>/dev/null; then
            echo "ACR Pull 権限は有効です"
          else
            az aks update --name "$AKS_CLUSTER_NAME" --resource-group "$RESOURCE_GROUP_NAME" --attach-acr "$ACR_NAME"
          fi

      - name: AKS に ACR 認証 Secret を用意
        run: |
          BOARD_NS=$(grep kubernetesNamespace "$KUSTOMIZE_DIR/vars.env" | cut -d'=' -f2)
          kubectl create namespace "$BOARD_NS" --dry-run=client -o yaml | kubectl apply -f -
          ACR_USERNAME=$(az acr credential show --name "$ACR_NAME" --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name "$ACR_NAME" --query "passwords[0].value" -o tsv)
          kubectl create secret docker-registry acr-secret \
            --docker-server="$ACR_LOGIN_SERVER" \
            --docker-username="$ACR_USERNAME" \
            --docker-password="$ACR_PASSWORD" \
            -n "$BOARD_NS" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: DB 接続 Secret(board-db-conn) を用意
        run: |
          set -euo pipefail
          BOARD_NS=$(grep kubernetesNamespace "$KUSTOMIZE_DIR/vars.env" | cut -d'=' -f2)
          kubectl create namespace "$BOARD_NS" --dry-run=client -o yaml | kubectl apply -f -
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Secret
          metadata:
            name: board-db-conn
            namespace: ${BOARD_NS}
          type: Opaque
          stringData:
            db-endpoint: "${DB_ENDPOINT}"
            db-username: "${DB_APP_USERNAME}"
            db-password: "${DB_APP_PASSWORD}"
          EOF

      - name: デプロイ用イメージ参照をエクスポート
        run: |
          echo "IMAGE_FULL=$ACR_LOGIN_SERVER/$BOARD_IMAGE_NAME:$IMAGE_TAG" >> "$GITHUB_ENV"
          echo "BOARD_API_IMAGE_FULL=$ACR_LOGIN_SERVER/$BOARD_API_IMAGE_NAME:$IMAGE_TAG" >> "$GITHUB_ENV"

      - name: Kustomize を適用してロールアウト
        run: |
          set -euo pipefail
          BOARD_NS=$(grep kubernetesNamespace "$KUSTOMIZE_DIR/vars.env" | cut -d'=' -f2)
          kubectl kustomize "$KUSTOMIZE_DIR" \
            | sed "s#acr-placeholder.azurecr.io/board-app:latest#${IMAGE_FULL}#g" \
            | sed "s#acr-placeholder.azurecr.io/board-api:latest#${BOARD_API_IMAGE_FULL}#g" \
            | kubectl apply -f -

          wait_rollout() {
            local deploy=$1
            local timeout=$2
            local mode=${3:-fail}
            echo "📦 Deployment $deploy のロールアウトを監視（タイムアウト: ${timeout}秒）"
            if ! kubectl rollout status deployment/"$deploy" -n "$BOARD_NS" --timeout="${timeout}s"; then
              echo "❌ Deployment $deploy のロールアウトが失敗しました" >&2
              kubectl get pods -n "$BOARD_NS" -l app="$deploy" -o wide || true
              kubectl describe deployment "$deploy" -n "$BOARD_NS" || true
              echo "直近のログ:"
              kubectl logs -n "$BOARD_NS" -l app="$deploy" --tail=50 --all-containers=true || true
              if [ "$mode" = "fail" ]; then
                exit 1
              else
                echo "⚠️ 警告モードのため続行します"
              fi
            fi
          }

          wait_rollout "board-app" 600 fail
          wait_rollout "board-api" 600 warn
          kubectl get ingress -n "$BOARD_NS"

      - name: デプロイ後の疎通確認
        run: |
          set -euo pipefail
          BOARD_NS=$(grep kubernetesNamespace "$KUSTOMIZE_DIR/vars.env" | cut -d'=' -f2)
          LB_IP=${ACTUAL_LB_IP:-$INGRESS_STATIC_IP}

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "デプロイ後の疎通確認"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          # クラスタ内から Service への直接アクセステスト
          echo "\n[1/4] クラスタ内から board-app Service へアクセス"
          if kubectl run tmp-curl --rm -i --restart=Never --image=curlimages/curl -n "$BOARD_NS" -- curl -sI http://board-app.board-app.svc.cluster.local/ | head -n1; then
            echo "✅ board-app Service 疎通成功"
          else
            echo "⚠️ board-app Service 疎通失敗（警告）"
          fi

          echo "\n[2/4] クラスタ内から board-api Service へアクセス"
          if kubectl run tmp-curl2 --rm -i --restart=Never --image=curlimages/curl -n "$BOARD_NS" -- curl -sI http://board-api.board-app.svc.cluster.local:3000/api/posts | head -n1; then
            echo "✅ board-api Service 疎通成功"
          else
            echo "⚠️ board-api Service 疎通失敗（警告）"
          fi

          # LoadBalancer 経由の外部アクセステスト
          echo "\n[3/4] LoadBalancer 経由で HTML を取得"
          if curl -sf "http://${LB_IP}/" -o /dev/null; then
            echo "✅ HTML 配信成功"
            curl -s "http://${LB_IP}/" | grep -o '<title>.*</title>' || echo "タイトルタグなし"
          else
            echo "❌ HTML 配信失敗"
            exit 1
          fi

          echo "\n[4/4] LoadBalancer 経由で API エンドポイントを確認"
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://${LB_IP}/api/posts" || echo "000")
          echo "API レスポンス: $API_STATUS"
          if [ "$API_STATUS" = "200" ] || [ "$API_STATUS" = "304" ]; then
            echo "✅ API エンドポイント疎通成功"
          else
            echo "⚠️ API エンドポイント応答異常 (HTTP $API_STATUS)。Ingress ルーティング設定を確認してください"
          fi

          echo "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

      - name: デプロイサマリを出力
        run: |
          BOARD_NS=$(grep kubernetesNamespace "$KUSTOMIZE_DIR/vars.env" | cut -d'=' -f2)
          LB_IP=${ACTUAL_LB_IP:-}
          echo "## 🎯 掲示板アプリ AKS デプロイ完了" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: \`$BOARD_NS\`" >> $GITHUB_STEP_SUMMARY
          echo "- **デプロイタグ**: \`$IMAGE_TAG\`" >> $GITHUB_STEP_SUMMARY
          echo "- **ACR**: \`$ACR_LOGIN_SERVER\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📍 アクセス" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -n "$LB_IP" ]; then
            echo "- **Load Balancer IP**: http://$LB_IP" >> $GITHUB_STEP_SUMMARY
            echo "- **ダミーシークレット**: http://$LB_IP/dummy-secret.txt" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ⚠️ LoadBalancer IP 取得待機中" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🔒 セキュリティスキャン結果" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # code-security-scans job の結果
          GITLEAKS="${{ needs.code-security-scans.outputs.gitleaks_issues || '0' }}"
          FS_CRITICAL="${{ needs.code-security-scans.outputs.trivy_fs_critical || '0' }}"
          FS_HIGH="${{ needs.code-security-scans.outputs.trivy_fs_high || '0' }}"

          # build-and-push job の結果
          IMG_CRITICAL="${{ needs.build-and-push.outputs.board_image_critical || '0' }}"
          IMG_HIGH="${{ needs.build-and-push.outputs.board_image_high || '0' }}"
          API_CRITICAL="${{ needs.build-and-push.outputs.api_image_critical || '0' }}"
          API_HIGH="${{ needs.build-and-push.outputs.api_image_high || '0' }}"

          # Gitleaks
          if [ "$GITLEAKS" = "0" ]; then
            echo "- ✅ **Gitleaks**: 秘密情報なし" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ⚠️ **Gitleaks**: $GITLEAKS 件の秘密情報検出" >> $GITHUB_STEP_SUMMARY
          fi

          # Trivy FS
          if [ "$FS_CRITICAL" = "0" ] && [ "$FS_HIGH" = "0" ]; then
            echo "- ✅ **Trivy FS** (ソース): CRITICAL 0件、HIGH 0件" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ⚠️ **Trivy FS** (ソース): CRITICAL $FS_CRITICAL 件、HIGH $FS_HIGH 件" >> $GITHUB_STEP_SUMMARY
          fi

          # Trivy Image (Board)
          if [ "$IMG_CRITICAL" = "0" ] && [ "$IMG_HIGH" = "0" ]; then
            echo "- ✅ **Trivy Image** (Board App): CRITICAL 0件、HIGH 0件" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ⚠️ **Trivy Image** (Board App): CRITICAL $IMG_CRITICAL 件、HIGH $IMG_HIGH 件" >> $GITHUB_STEP_SUMMARY
          fi

          # Trivy Image (Board API)
          if [ "$API_CRITICAL" = "0" ] && [ "$API_HIGH" = "0" ]; then
            echo "- ✅ **Trivy Image** (Board API): CRITICAL 0件、HIGH 0件" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ⚠️ **Trivy Image** (Board API): CRITICAL $API_CRITICAL 件、HIGH $API_HIGH 件" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> 詳細は [Security タブ](https://github.com/${{ github.repository }}/security/code-scanning) を確認してください" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📦 Pod 状態" >> $GITHUB_STEP_SUMMARY
          echo "```" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n "$BOARD_NS" -o wide >> $GITHUB_STEP_SUMMARY
          echo "```" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🌐 Ingress 状態" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get ingress -n "$BOARD_NS" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🔍 疎通確認" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://${LB_IP}/api/posts" || echo "000")
          if [ "$API_STATUS" = "200" ] || [ "$API_STATUS" = "304" ]; then
            echo "- ✅ API エンドポイント: HTTP $API_STATUS" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ⚠️ API エンドポイント: HTTP $API_STATUS (要確認)" >> $GITHUB_STEP_SUMMARY
          fi
